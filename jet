#!/usr/bin/env node

const cap = require('caporal');
const importLazy = require('import-lazy')(require);
const {version} = importLazy('./package');

const lndClient = importLazy('./api/connect');
const {listActiveRebalancesFormattedSync} = importLazy('./api/utils');
const {rebalanceHistoryFormattedSync} = importLazy('./api/utils');
const {pendingHtlcsFormattedSync} = importLazy('./api/utils');
const {listForcedClosingFormattedSync} = importLazy('./api/utils');
const {listPeersFormattedSync} = importLazy('./api/utils');
const {readLastLineSync} = importLazy('./api/utils');
const {withCommas} = importLazy('./lnd-api/utils');
const {listFeesSync} = importLazy('./lnd-api/utils');
const {listPeersSync} = importLazy('./lnd-api/utils');
const {listPeersMapSync} = importLazy('./lnd-api/utils');
const {listChannelsSync} = importLazy('./lnd-api/utils');
const {closeChannel} = importLazy('./lnd-api/utils');
const {updateChannelSync} = importLazy('./lnd-api/update-channel');
const {listChannels} = importLazy('./api/list-channels');
const {htlcHistoryFormatted} = importLazy('./api/htlc-history');
const {htlcAnalyzerFormatted} = importLazy('./api/htlc-analyzer');
const {htlcAnalyzerNode} = importLazy('./api/htlc-analyzer');
const {classifyPeersSync} = importLazy('./api/utils');
const {resolveNode} = importLazy('./api/utils');
const {resolveChannel} = importLazy('./api/utils');
const {feeHistorySync} = importLazy('./db/utils');
const {listChannelEvents} = importLazy('./db/utils');
const {latestChannelEvents} = importLazy('./db/utils');

const {statSync} = require('fs');
const date = require('date-and-time');

const serviceUtils = importLazy('./service/utils');
const {getServiceNames} = importLazy('./service/utils');
const {stopService} = importLazy('./service/utils');
const {startService} = importLazy('./service/utils');
const {restartService} = importLazy('./service/utils');
const {printStatus} = importLazy('./service/utils');
const {rebalanceStatus} = importLazy('./api/analyze-fees');
const constants = importLazy('./api/constants');
const config = importLazy('./api/config');

const rebalanceApi = importLazy('./api/rebalance');
const {reconnect} = importLazy('./bos/reconnect');
const {isLndAlive} = importLazy('./lnd-api/utils');
const {inactiveChannels} = importLazy('./api/list-channels');


const isInt = value => {
  var x = parseFloat(value);
  return !isNaN(value) && (x | 0) === x;
}

// service names, plus all for restart
const serviceNames = getServiceNames();
var serviceNamesPlus = serviceNames.slice();
serviceNamesPlus.push('all');

cap
  .version(version)

  .command('info', 'Information about this node, another node, or a channel')
  .argument('[id]', 'Node id, node partial alias, or channel id')
  .option('--db', 'Lists db tables sorted by size')
  .help('Returns various node or channel stats')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (options.db) {
        // print db stats
        const {stats} = require('./db/utils');
        console.log('lists database tables sorted by size:');
        console.table(stats());
        return;
      }

      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const {withCommas} = require('./lnd-api/utils');
      const {getChanInfo} = require('./lnd-api/utils');
      const {getNodeInfoSync} = require('./lnd-api/utils');
      const {getInfoSync} = require('./lnd-api/utils');
      if (args.id) {
        // locate node or channel
        let matches = resolveNode(args.id);
        if (matches && matches.length > 0) {
          if (matches.length > 1) return console.log('multiple node matches found; narrow your selection');
          printNode(matches[0].id);
        } else {
          // try to resolve channel
          matches = resolveChannel(args.id);
          if (matches && matches.length > 0) {
            if (matches.length > 1) return console.error('multiple channel matches found; narrow your selection');
            printChan(matches[0]);
          } else {
            // no matches out of existing peers, query for node id directly
            if (printNode(args.id)) {
              // already printed node stats
            } else if (printChan(args.id)) {
              // already printed chan stats
            } else {
              console.log('no matches found');
            }
          }
        }
        return;

        function printNode(id) {
           try {
            const info = getNodeInfoSync(lndClient, id).info;
            if (!info) return;
            console.log('pub id:', info.node.pub_key);
            console.log('name:', info.node.alias);
            console.log('total chans:', info.num_channels);
            console.log('total capacity:', withCommas(info.total_capacity), '(sats)');
            return info;
          } catch(err) {
            // no need to print error
          }
        }

        function printChan(id) {
          try {
            const info = getChanInfo(lndClient, id);
            if (!info) return;
            console.log('chan id:', info.chan.channel_id);
            console.log('capacity:', withCommas(info.chan.capacity));
            const myNode = getInfoSync(lndClient).identity_pubkey;
            const peer1 = getNodeInfoSync(lndClient, info.chan.node1_pub);
            const peer2 = getNodeInfoSync(lndClient, info.chan.node2_pub);
            if (peer1.info.node.pub_key === myNode) {
              console.log('peer:', peer2.info.node.alias + ', ' + peer2.info.node.pub_key);
            } else if (peer2.info.node.pub_key === myNode) {
              console.log('peer:', peer1.info.node.alias + ', ' + peer1.info.node.pub_key);
            } else {
              console.log('peer1:', peer1.info.node.alias + ', ' + peer1.info.node.pub_key);
              console.log('peer2:', peer2.info.node.alias + ', ' + peer2.info.node.pub_key);
            }
            return info;
          } catch(err) {
            // no need to print error
          }
        }
      }

      const nodeInfo = getInfoSync(lndClient);
      const {walletBalance} = require('./lnd-api/utils');
      const balance = walletBalance(lndClient);
      const {checkSize} = require('./api/channeldb');
      const check = checkSize();
      const {jetDbStats} = require('./api/utils');
      const stats = jetDbStats();

      console.log('lnd version:', nodeInfo.version);
      console.log('node id:', nodeInfo.identity_pubkey);
      console.log('node alias:', nodeInfo.alias);
      console.log('total chans:', nodeInfo.num_active_channels + nodeInfo.num_inactive_channels);
      console.log('--active:', nodeInfo.num_active_channels);
      console.log('--inactive:', nodeInfo.num_inactive_channels);

      if (balance.response) {
        console.log('bitcoin balance (sats):', withCommas(balance.response.total_balance));
        console.log('--confirmed:', withCommas(balance.response.confirmed_balance));
        console.log('--unconfirmed:', withCommas(balance.response.unconfirmed_balance));
      }

      if (check.error) console.log('channel.db:', check.error);
      else {
        const str = (check.size >= 1000) ? withCommas(check.size) + ' gb' : check.size + ' mb'
        console.log('channel.db:', str);
      }

      if (stats) {
        console.log('jet.db:', stats.str);
      }
    })
  })

  .command('start', 'Starts a service')
  .argument('<service>', 'Service; use \'all\' to restart all services', serviceNamesPlus)
  .help(`Services: ${serviceNames.join(', ')}`)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let msg = startService(args.service);
      if (msg) console.log(msg);
    })
  })

  .command('stop', 'Stops a service')
  .argument('<service>', 'Service; use \'all\' to restart all services', serviceNamesPlus)
  .help(`Services: ${serviceNames.join(', ')}`)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      stopService(args.service);
    })
  })

  .command('restart', 'Restarts a service')
  .argument('<service>', 'Service; use \'all\' to restart all services', serviceNamesPlus)
  .help(`Services: ${serviceNames.join(', ')}`)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      restartService(args.service);
    })
  })

  .command('status', 'Shows services status')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      printStatus();
    })
  })

  .command('stats', 'Shows channel profitability stats')
  .option('--days [days]', 'Depth of history in days; max of ' + Math.floor(constants.maxTxnInterval/24) + ' days, default ' + Math.floor(constants.defaultTxnInterval/24))
  .option('--hours [hours]', 'Depth of history in hours; max of ' + Math.floor(constants.maxTxnInterval/24) + ' days, default ' + Math.floor(constants.defaultTxnInterval/24))
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const hours = options.hours || (options.days && options.days * 24) || constants.defaultTxnInterval;
      if (hours > constants.maxTxnInterval) return console.error('history depth exceeds the max of ' + constants.maxTxnInterval + ' hours (' + Math.floor(constants.maxTxnInterval/24) + ' days)');

      const msec = new Date(new Date().toUTCString()).getTime();
      const fromTimestamp = (msec - hours * 60 * 60 * 1000) * Math.pow(10, 6);
      const {txnByChanAndType} = require('./db/utils');
      const list = txnByChanAndType(fromTimestamp);
      if (!list || list.length === 0) return console.log('no records found');

      // get historical record to display % change
      const fromT = (msec - 2 * hours * 60 * 60 * 1000) * Math.pow(10, 6);
      const toT = (msec - hours * 60 * 60 * 1000) * Math.pow(10, 6);
      const prevList = txnByChanAndType(fromT, toT);
      let historyMap = {};
      let historyTotal = {
        profit: 0,
        inbound: { amount: 0 },
        forward: { fee: 0, amount: 0 },
        rebalance: { fee: 0, amount: 0 }
      }
      if (prevList && prevList.length > 0) {
        prevList.sort((a, b) => a.txdate_ns - b.txdate_ns);
        prevList.forEach(item => {
          if (!historyMap[item.chan]) historyMap[item.chan] = { 
            forward: { fee: 0, amount: 0 },
            inbound: { amount: 0 },
            rebalance: { fee: 0, amount: 0 }
          }
          if (item.type === 'forward') {
            historyMap[item.chan].forward.fee = item.total_fee;
            historyMap[item.chan].forward.amount = item.total_amount;
            historyTotal.forward.fee += item.total_fee;
            historyTotal.forward.amount += item.total_amount;
          } else if (item.type === 'inbound') {
            historyMap[item.chan].inbound.amount = item.total_amount;
          } else if (item.type === 'rebalance') {
            historyMap[item.chan].rebalance.fee = item.total_fee;
            historyMap[item.chan].rebalance.amount = item.total_amount;
            historyTotal.rebalance.fee += item.total_fee;
            historyTotal.rebalance.amount += item.total_amount;
          }
          historyMap[item.chan].delta = historyMap[item.chan].forward.fee - historyMap[item.chan].rebalance.fee;
        })
        historyTotal.profit = historyTotal.forward.fee - historyTotal.rebalance.fee;
      }

      let chanMap = {};
      const chans = listChannelsSync(lndClient);
      chans.forEach(c => {
        chanMap[c.chan_id] = c.remote_pubkey;
      })
      let peerMap = {};
      const peers = listPeersSync(lndClient);
      peers.forEach(p => {
        peerMap[p.id] = p.name;
      })
      let map = {};
      list.forEach(item => {
        const chan = item.chan;
        if (!map[chan]) map[chan] = {};
        let p = map[chan];
        if (item.type === 'forward') {
          p.forward = {
            amount: item.total_amount,
            fee: item.total_fee
          }
        } else if (item.type === 'inbound') {
          p.inbound = {
            amount: item.total_amount
          }
        } else if (item.type === 'rebalance') {
          p.rebalance = {
            amount: item.total_amount,
            fee: item.total_fee
          }
        }
      })
      let combined = [];
      Object.keys(map).forEach(k => {
        let item = {};
        item.chan = k;
        item.peer = chanMap[k];
        item.name = peerMap[chanMap[k]];
        if (map[k].forward) item.forward = map[k].forward;
        if (map[k].inbound) item.inbound = map[k].inbound;
        if (map[k].rebalance) item.rebalance = map[k].rebalance;
        const feeForward = (item.forward && item.forward.fee) || 0;
        const feeRebalance = (item.rebalance && item.rebalance.fee) || 0;
        item.delta = feeForward - feeRebalance;
        combined.push(item);
      })

      // print cumulative stats
      const {withCommas} = require('./lnd-api/utils');
      let total = 0;
      let totalForwarded = { amount: 0, fee: 0 };
      let totalRebalanced = { amount: 0, fee: 0 };
      combined.forEach(item => {
        total += item.delta;
        totalForwarded.amount += (item.forward && item.forward.amount) || 0;
        totalForwarded.fee += (item.forward && item.forward.fee) || 0;
        totalRebalanced.amount += (item.rebalance && item.rebalance.amount) || 0;
        totalRebalanced.fee += (item.rebalance && item.rebalance.fee) || 0;
      })

      let str = 'cumulative stats';
      const days = isInt(hours/24) && Math.floor(hours/24);
      if (days) str += ' over the past ' + days + ' day(s)';
      else str += ' over the past ' + hours + ' hour(s)';
      console.log(str + ':');

      let cumulative = [];
      cumulative.push({
        period: 'current',
        profit: total,
        forwarded: withCommas(totalForwarded.amount),
        earned: totalForwarded.fee,
        rebalanced: withCommas(totalRebalanced.amount),
        paid: totalRebalanced.fee
      })
      cumulative.push({
        period: 'previous',
        profit: historyTotal.profit,
        forwarded: withCommas(historyTotal.forward.amount),
        earned: historyTotal.forward.fee,
        rebalanced: withCommas(historyTotal.rebalance.amount),
        paid: historyTotal.rebalance.fee
      })
      console.log('this table displays data for two time periods, current and previous; e.g. display weekly data over the past week along with the data from a week ago');
      console.table(cumulative);

      // profitable channels
      let profitable = [];
      combined.forEach(item => {
        if (item.delta <= 0) return;
        let rec = {
          chan: item.chan,
          peer: item.name,
          profit: item.delta,
          inbound: (item.inbound && item.inbound.amount) || 0,
          outbound: (item.forward && item.forward.amount) || 0,
          earned: (item.forward && item.forward.fee) || 0,
          rebalanced: (item.rebalance && item.rebalance.amount) || 0,
          paid: (item.rebalance && item.rebalance.fee) || 0,
        }
        const prev = historyMap[item.chan] && historyMap[item.chan].delta;
        if (prev !== undefined && prev !== 0) {
          const delta = rec.profit - prev;
          if (delta !== 0) {
            rec.delta = delta;
          }
          if (historyMap[item.chan].forward.amount !== 0) rec['delta_fw %'] = Math.round(100 * (rec.outbound - historyMap[item.chan].forward.amount) / historyMap[item.chan].forward.amount);
          if (historyMap[item.chan].rebalance.amount !== 0) rec['delta_rb %'] = Math.round(100 * (rec.rebalanced - historyMap[item.chan].rebalance.amount) / historyMap[item.chan].rebalance.amount);
        }
        profitable.push(rec);
      })
      profitable.sort((a, b) => b.profit - a.profit);

      console.log('\nprofitable channels:');
      if (profitable.length === 0) console.log('none found');
      else {
        console.log('-profit: profit in sats');
        console.log('-inbound: total inbound sats')
        console.log('-outbound: total outbound sats');
        console.log('-earned: total sats earned on forwards (outbound)');
        console.log('-rebalanced: total sats rebalanced');
        console.log('-paid: total sats paid for rebalances');
        console.log('-delta: change in profit (sats) since the last interval; e.g. 15 means that the profit has increased by 15 sats');
        console.log('-delta_fw: change in sats (%) forwarded since the last interval; e.g. 25 means that the node forwarded 25% more sats comparing to the last interval');
        console.log('-delta_rb: change in sats (%) rebalanced since the last interval; e.g. 25 means that the node rebalanced 25% more sats comparing to the last interval');
        console.table(profitable);
      }

      // unprofitable channels
      let unprofitable = [];
      combined.forEach(item => {
        if (item.delta > 0) return;
        let rec = {
          chan: item.chan,
          peer: item.name,
          loss: Math.abs(item.delta), // present loss as a positive integer
          inbound: (item.inbound && item.inbound.amount) || 0,
          outbound: (item.forward && item.forward.amount) || 0,
          earned: (item.forward && item.forward.fee) || 0,
          rebalanced: (item.rebalance && item.rebalance.amount) || 0,
          paid: (item.rebalance && item.rebalance.fee) || 0,
        }
        const prev = historyMap[item.chan] && historyMap[item.chan].delta;
        if (prev !== undefined && prev !== 0) {
          const delta = -(item.delta - prev);
          if (delta !== 0) {
            rec.delta = delta;
          }
          if (historyMap[item.chan].forward.amount !== 0) rec['delta_fw %'] = Math.round(100 * (rec.outbound - historyMap[item.chan].forward.amount) / historyMap[item.chan].forward.amount);
          if (historyMap[item.chan].rebalance.amount !== 0) rec['delta_rb %'] = Math.round(100 * (rec.rebalanced - historyMap[item.chan].rebalance.amount) / historyMap[item.chan].rebalance.amount);
        }
        unprofitable.push(rec);
      })
      unprofitable.sort((a, b) => b.loss - a.loss);

      console.log('\nunprofitable channels:');
      if (unprofitable.length === 0) console.log('none found');
      else {
        console.log('-delta: change in loss (sats) since the last interval; e.g. 15 means that the loss has increased by 15 sats');
        console.table(unprofitable);
      }
    })
  })

  .command('probes', 'Displays nodes (discovered during probes) that have signaled a commitment to liquidity. This tool can be used to identify prospects for new channels.')
  .option('--days [days]', 'Depth of history in days')
  .option('--hours [hours]', 'Depth of history in hours')
  .option('--top [n]', 'Return top n records, default ' + constants.defaultProbeTopN)
  .option('--all', 'Return all records')
  .option('--peers', 'Shows probe data for current peers (as opposed to new nodes)')
  .option('--sort [col]', 'Sort by a column', ['sats_sum', 'count', 'avg_ppm', 'min_ppm', 'max_ppm'])
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      if (options.top && options.top <= 1) return console.error('--top must be above or equal to 1');
      const top = (options.all) ? options.top : options.top || constants.defaultProbeTopN;

      const hours = (options.all) ? options.hours || (options.days && options.days * 24) : options.hours || (options.days && options.days * 24) || constants.defaultProbeInterval;
      const maxInterval = constants.maxProbeInterval;
      if (hours > maxInterval) return console.error('provided depth exceeds the max of ' + maxInterval + ' hours (' + maxInterval / 24 + ' days)');

      const msec = new Date(new Date().toUTCString()).getTime();
      const fromDate = hours && (msec - hours * 60 * 60 * 1000);

      const sortCol = options.sort || 'count';

      const {reportLiquidity} = require('./db/utils');
      const list = reportLiquidity(fromDate);
      if (!list || list.length === 0) return console.log('no records found');

      if (sortCol === 'sats_sum') {
        list.sort((a, b) => { return b.sats_sum - a.sats_sum });
      } else if (sortCol === 'count') {
        list.sort((a, b) => { return b.count - a.count });
      } else if (sortCol === 'avg_ppm') {
        list.sort((a, b) => { return a.avg_ppm - b.avg_ppm });
      } else if (sortCol === 'min_ppm') {
        list.sort((a, b) => { return a.min_ppm - b.min_ppm });
      } else if (sortCol === 'max_ppm') {
        list.sort((a, b) => { return b.max_ppm - a.max_ppm });
      } else {
        console.error('unknown sort column,', sortCol);
      }

      const peers = listPeersSync(lndClient);
      let peerMap = {};
      peers.forEach(p => {
        peerMap[p.id] = p;
      })
      const days = Math.max(1, Math.round(hours / 24));
      const classified = classifyPeersSync(lndClient, days);
      let cmap = {};
      if (classified.inbound) {
        classified.inbound.forEach(p => {
          cmap[p.peer] = { type: 'inbound', node: p }
        })
      }
      if (classified.outbound) {
        classified.outbound.forEach(p => {
          cmap[p.peer] = { type: 'outbound', node: p }
        })
      }
      if (classified.balanced) {
        classified.balanced.forEach(p => {
          cmap[p.peer] = { type: 'low volume', node: p }
        })
      }

      let formatted = [];
      list.forEach(item => {
        if (!options.peers && peerMap[item.node]) return;
        if (options.peers && !peerMap[item.node]) return;
        if (peerMap[item.node]) {
          let s = {
            peer: item.node,
            name: peerMap[item.node].name,
            count: item.count,
            sats_sum: item.sats_sum,
            avg_ppm: item.avg_ppm,
            min_ppm: item.min_ppm,
            max_ppm: item.max_ppm
          }
          if (cmap[item.node]) {
            s.local = withCommas(cmap[item.node].node.local);
            s.type = cmap[item.node].type;
          }
          formatted.push(s);
          peerMap[item.node].included = true;
        } else {
          formatted.push(item);
        }
      })
      if (top) formatted = formatted.slice(0, top);

      let str = 'probe data showing nodes that signaled commitment of liquidity\n';
      if (options.peers) str += 'analyzing data for existing peers (as opposed to prospects for new channels)\n'
      str += 'data generated'
      if (hours) {
        const days = isInt(hours/24) && Math.floor(hours/24);
        if (days) str += ' over the past ' + days + ' day(s)';
        else str += ' over the past ' + hours + ' hour(s)';
      } else {
        str += ' since the beginning'
      }
      if (top) str += '; returning top ' + top + ' records';
      str += '; sorted by ' + sortCol;
      console.log(str + '\n');
      console.log('-count: total number of times a node signaled commitment of liquidity');
      console.log('-sats_sum: total number of sats a node signaled to commit');
      console.log('-avg_ppm: average ppm of [commited] liquidity');
      if (options.peers) {
        console.log('-local: sats on the local side (assumes one channel per peer)');
        console.log("-type: peer's classification info inbound, outbound and low-volume");
      }
      console.table(formatted);

      if (options.peers) {
        let none = [];
        Object.keys(peerMap).forEach(k => {
          if (!peerMap[k].included) none.push({peer: k, name: peerMap[k].name});
        })
        if (none.length > 0) {
          console.log('\npeers that havent signaled any commitment of liquidity');
          console.table(none);
        }
      }
    })
  })

  .command('rebalance', 'Rebalances the node via circular rebalance.')
  .help('Calls BalanceOfSatoshis rebalance api in a loop until the target amount is met or all possible routes are exhausted.')
  .argument('<from>', 'From this peer. Can be a partial alias, a pub id, or a bos tag')
  .argument('<to>', 'To this peer. Can be a partial alias, a pub id, or a bos tag')
  .argument('<amount>', 'Amount in sats')
  .option('--ppm <ppm>', 'Max ppm')
  .option('--mins [mins]', 'Max time to run in minutes')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const amount = (args.amount < 1000) ? args.amount * 1000000 : args.amount;

      try {
        rebalanceApi({
          from: args.from,
          to: args.to,
          amount: amount,
          ppm: options.ppm,
          mins: options.mins
        })  
      } catch(err) {
        console.error(err.message);
      }
    })
  })

  .command('peers', 'Lists peers classified into inbound, outbound and balanced based on routing history')
  .help('Notable columns: p - % of [inbound or outbound] routing by the peer out of total [inbound or outbound] across all peers; ppm - peer\'s current ppm rate; margin - rebalance ppm margin, rebalance will be profitable as long as its ppm is below this margin.')
  .option('--days [days]', 'Depth of routing history in days')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const days = options.days || 1;
      let peers = listPeersFormattedSync(days);
      console.log('classification of peers based on past', days, 'day(s):');
      console.log('-local: total sats on local side (excluding htlcs)')
      console.log('-remote: total sats on remote side (excluding htlcs)')
      if (peers.inbound.length > 0) {
        console.log('\ninbound peers:');
        console.table(peers.inbound);
      } else {
        console.log('no inbound peers found');
      }
      if (peers.outbound.length > 0) {
        console.log('\noutbound peers:');
        console.table(peers.outbound);
      } else {
        console.log('no outbound peers found');
      }
      if (peers.balanced.length > 0) {
        console.log('\nlow routing volume peers:');
        console.table(peers.balanced);
      }
      if (peers.skipped.length > 0) {
        console.log('\nskipped peers:');
        console.table(peers.skipped);  
      }
      if (peers.all.length > 0) {
        console.log('\nall peers:');
        console.table(peers.all);
      } else {
        console.log('no peers found');
      }
    })
  })

  .command('fees', 'Lists peer fees')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      let fees = listFeesSync(lndClient);
      //console.log(classified);
      //console.log(fees);
      let formatted = [];
      fees.forEach(f => {
        let name = f.name;
        formatted.push({
          peer: f.name,
          lc_base: f.local.base,
          lc_rate: f.local.rate,
          rm_base: f.remote.base,
          rm_rate: f.remote.rate
        })
      })
      formatted.sort(function(a, b) {
        return b.rm_rate - a.rm_rate;
      })
      console.table(formatted);
    })
  })

  .command('analyze-fees', 'Analyzes peer fees')
  .argument('[node]', 'Pub id or an alias (full or partial) of [outbound] node for fee analysis')
  .option('--profit [profit]', 'Profit margin in % to evaluate fees against')
  .help('Each peers\' channel local and remote fees will be evaluated against the profitability margin')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      if (options.profit < 0 || options.profit > 100) return console.error('profit has to be between 0 and 100');

      const {printFeeAnalysis} = require('./api/analyze-fees');
      let classified = classifyPeersSync(lndClient);
      let chans = [];
      let nodesFound = [];
      if (classified.outbound) {
        classified.outbound.forEach(c => {
          chans.push({chan: c.id, peer: c.peer});
          if (args.node) {
            let lc1 = c.name && c.name.toLowerCase();
            let lc2 = args.node.toLowerCase();
            if (args.node === c.peer || (lc1 && lc1.indexOf(lc2) >= 0)) {
              nodesFound.push(c);
            }
          }
        })
      }
      if (classified.balanced) {
        classified.balanced.forEach(c => {
          chans.push({chan: c.id, peer: c.peer});
          if (args.node) {
            let lc1 = c.name && c.name.toLowerCase();
            let lc2 = args.node.toLowerCase();
            if (args.node === c.peer || (lc1 && lc1.indexOf(lc2) >= 0)) {
              nodesFound.push(c);
            }
          }
        })
      }
      if (args.node) {
        if (nodesFound.length >= 2) {
          let matches = [];
          nodesFound.forEach(n => matches.push(n.name));
          return console.error('multiple node matches found:', matches);
        }
        if (nodesFound.length === 0) return console.error('node not found (possibly an inbound node)');
        let node = nodesFound[0];
        chans = [{chan: node.id, peer: node.peer}];
        let fees = listFeesSync(lndClient, chans);
        return printFeeAnalysis(node.name, node.peer, fees[0].local, fees[0].remote, options.profit);
      }

      let fees = listFeesSync(lndClient, chans);
      let feeMap = {};
      fees.forEach(f => feeMap[f.id] = f);

      let msg = 'analyzing fees for [outbound] peers';
      msg += (options.profit) ? ' based on profit of ' + options.profit + '%' : '. no profit requirements specified'
      console.log('-------------------------------------------------------------')
      console.log(msg);
      console.log('-------------------------------------------------------------')
 
      let unknownPeers = [];
      let count = 0;
      classified.outbound.forEach(c => {
        console.log();  // newline
        if (!feeMap[c.peer]) unknownPeers.push({name: c.name, id: c.peer});
        let num = printFeeAnalysis(c.name, c.peer, feeMap[c.peer].local, feeMap[c.peer].remote, options.profit);
        count += num;
      })
      if (count === 0) console.log('no issues to report');

      msg = 'analyzing fees for [balanced] peers';
      msg += (options.profit) ? ' based on profit of ' + options.profit + '%' : '. no profit requirements specified'
      console.log('\n-------------------------------------------------------------')
      console.log(msg);
      console.log('-------------------------------------------------------------')

      count = 0;
      classified.balanced.forEach(c => {
        console.log();  // newline
        if (!feeMap[c.peer]) unknownPeers.push({name: c.name, id: c.peer});
        let num = printFeeAnalysis(c.name, c.peer, feeMap[c.peer].local, feeMap[c.peer].remote, options.profit);
        count += num;
      })
      if (count === 0) console.log('no issues to report');

      if (unknownPeers.length > 0) {
        console.log(constants.colorYellow, '\nunknown fee data for the following peers (excluded):');
        unknownPeers.forEach(p => {
          console.log(p.name, p.id);
        })
      }
    })
  })

  .command('htlc-history', 'Prints cumulative htlcs history for peers')
  .argument('[days]', 'Depth of history in days')
  .help('Prints % of total inbound / outbound routing for each peer (e.g. inbound routing from D++ takes 25% of total inbound traffic across all peers), and % of inbound / outbound routing for a peer (e.g. inbound routing from D++ takes 95% of total routing from D++)')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      let days = args.days || 7;  // hardcoded??
      let history = htlcHistoryFormatted(days);
      console.log('htlc history over the past', days, 'days');
      if (history.unknown) {
        console.log('unknown channels:', history.unknown);
      }
      console.log('inbound routing:');
      console.table(history.inbound);
      console.log('outbound routing:');
      console.table(history.outbound);
      if (history.noTraffic) {
        console.log('no routing:');
        console.table(history.noTraffic);
      }
    })
  })

  .command('htlc-analyzer', 'Prints stats about failed htlcs')
  .argument('[node]', 'Pub id or an alias (full or partial) of [outbound] node for htlc analysis')
  .option('--days [days]', 'Depth of history in days. Can provide partial days, e.g., .5 days (12 hours)')
  .option('--hours [hours]', 'Depth of history in hours.')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      try {
        let days = options.days || 1;
        days = (options.hours) ? options.hours / 24 : days;

        let showDays = isInt(days) ? days : days.toFixed(2);
        let showHours = isInt(days * 24) ? days * 24 : (days * 24).toFixed(1);
        console.log('htlc analysis over the past', showDays, 'day(s) or', showHours, 'hour(s)');
        console.log('terminology: missed routing opportunity are htlcs that an [outbound] peer would\'ve routed if it had enough [local] liquidity');

        if (args.node) {
          let formatted = htlcAnalyzerNode(args.node, days);
          if (formatted) {
            console.log('node: ' + formatted.stats.name + ', ' + formatted.stats.id);
            console.log('missed htlc count: ' + formatted.stats.count + ', total missed sats: ' + withCommas(formatted.stats.total) + ', avg htlc size in sats: ' + withCommas(formatted.stats.avg));

            console.log('\ndetailed breakdown of missed htlcs for [inbound] peers:');
            console.log('-from: [inbound] peer that attempted to route sats');
            console.log('-sats: total missed sats for the peer');
            console.log('-count: # of missed htlcs');
            console.log('-avg: average htlc size in sats');
            console.table(formatted.peers);

            console.log('\ndetailed list of missed htlcs:');
            console.table(formatted.list);
          } else {
            console.log('no missed htlcs found');
          }
        } else {
          let formatted = htlcAnalyzerFormatted(days);
          if (formatted) {
            console.log('\ndetailed breakdown of missed htlcs for [outbound] peers:');
            console.log('-to: [outbound] peer that attempted to route sats');
            console.log('-sats: total missed sats for the peer');
            console.log('-count: # of missed htlcs');
            console.log('-avg: average htlc size in sats');
            console.log('-p: total missed sats for the peer as a % of the total across all peers');
            console.table(formatted.peers);

            console.log('\ndetailed breakdown of missed htlcs for peer pairs:');
            console.log('-from: [inbound] peer that attempted to route sats');
            console.log('-to: [outbound] peer');
            console.log('-sats: total missed sats for the [outbound] peer');
            console.log('-avg: average htlc size in sats');
            console.log('-count: # of missed htlcs');
            console.log('-p: total missed sats for the peer pair as a % of the total across all peers');
            console.table(formatted.list);
          } else {
            console.log('no missed htlcs found');            
          }
        }
      } catch(error) {
        console.error(error.toString());
      }
    })
  })

  .command('rebalance-history', 'Lists past rebalances')
  .argument('[node]', 'Pub id or an alias (full or partial)')
  .option('--mins [mins]', 'Depth of history in minutes')
  .option('--hours [hours]', 'Depth of history in hours')
  .option('--filter [filter]', 'Filter by success or failed', ['success', 'failed'])
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      let secs = (options.hours) ? options.hours * 60 * 60 : -1;
      secs = (options.mins) ? options.mins * 60 : secs;
      
      // find matches
      let id;
      let name;
      if (args.node) {
        let matches = resolveNode(args.node);
        if (!matches) return console.error('no matches found');
        else if (matches.length >= 2) return console.error('multiple matches found:', matches);
        id = matches[0].id;
        name = matches[0].name;
      }

      let formatted = rebalanceHistoryFormattedSync(secs, options.filter, id);
      let msg = 'rebalance history';
      if (options.mins) msg += ' over the past ' + options.mins + ' min(s)';
      if (options.hours) msg += ' over the past ' + options.hours + ' hour(s)';
      if (name) msg += ' for ' + name;
      msg += '\n  date  - when rebalance started';
      msg += '\n  secs  - how long rebalance ran in seconds';
      msg += '\n  min   - minimum max ppm required for rebalance to go through';
      msg += '\n  type  - rebalance type: regular (from inbound to outbound peers), low volume (between low volume peers), missed (based on missed htlcs), forward (ad-hock on forwards)';
      console.log(msg);
      if (!formatted || formatted.length === 0) console.log('no entries found');
      else console.table(formatted);
    })
  })

  .command('list-peers', 'Lists peer aliases and ids')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      let peers = listPeersSync(lndClient);
      let peerNames = [];
      peers.forEach(p => {
        peerNames.push({
          name: (p.active) ? p.name : '💀 ' + p.name,
          id: p.id,
          active: p.active
        })
      })
      peerNames.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      })
      console.table(peerNames);
    })
  })

  .command('list-channels', 'Lists channels: active, inactive and force closing. Lists top ten channels sorted based on channel state updates')
  .help('Lists channels: active, inactive and force closing. Lists top ten channels sorted based on channel state updates')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const chans = listChannels();
      if (!chans) return console.log('no channels found, likely due to an error');
      if (chans.active && chans.active.length > 0) {
        console.log('all channels:');
        console.table(chans.active);
      }

      // list inactive channels if any
      const inactive = inactiveChannels();
      if (inactive && inactive.length > 0) {
        console.log('\ninactive channels:\n-mins: shows how long a channel has been inactive in minutes (based on recorded channel events)');
        console.table(inactive);
      }

      if (chans.updates && chans.updates.length > 0) {
        console.log('\ntop channels based on updates:');
        console.log('-updates: number of channel state updates');
        console.log('-p: channel updates as a % out of the total across all channels');
        console.table(chans.updates);
      }
      if (chans.waitingClose && chans.waitingClose.length > 0) {
        console.log('\nwaiting close channels:');
        console.table(chans.waitingClose);
      }
      if (chans.pending && chans.pending.length > 0) {
        console.log('\nforce closing channels:');
        console.log('-limbo: number of sats in limbo state');
        console.log('-htlcs: number of pending htlcs');
        console.log('-maturity: blocks till maturity');
        console.log('-time: hours till maturity');
        console.table(chans.pending);
      }
    })
  })

  .command('monitor', 'Prints information about ongoing rebalances and stuck htlcs')
  .argument('[secs]', 'Refresh delay in seconds')
  .option('--status', 'Prints rebalance status for peers')
  .option('--current', 'Lists rebalances in progress')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const delay = args.secs || constants.monitor.refresh;  // in seconds
      const inProgress = !!options.current;
      console.log('loading data...');
      if (options.status) {
        runMonitorStatusLoop();
        setInterval(runMonitorStatusLoop, delay * 1000);
      } else {
        runMonitorLoop(inProgress);
        setInterval(runMonitorLoop, delay * 1000, inProgress);
      }
    })
  })

  .command('fee-history', 'Prints fee history for a peer')
  .argument('[node]', 'Pub id or an alias (full or partial)')
  .option('--hours [hours]', 'Depth of history in hours')
  .option('--days [days]', 'Depth of history in days')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      // find matches
      let id, name, peerMap;

      if (args.node) {
        let matches = resolveNode(args.node);
        if (!matches) return console.error('no matches found');
        else if (matches.length >= 2) return console.error('multiple matches found:', matches);

        id = matches[0].id;
        name = matches[0].name;
      } else {
        peerMap = {};
        let peers = listPeersSync(lndClient);
        peers.forEach(p => peerMap[p.id] = p.name);
      }

      let hours = options.hours || (options.days && options.days * 24) || 24 * 7;  // one week by default
      let req = {mins:hours * 60};
      if (id) req.node = id;
      let history = feeHistorySync(req);

      let str;
      if (hours > 24) {
        str = Math.floor(hours/24) + ' days';
        if (hours%24 > 0) str += ' and ' + hours%24 + ' hours';
      } else {
        str = hours + ' hours';
      }

      if (name) console.log('fee history for', name, 'over the past', str);
      else console.log('fee history over the past', str);
      if (!history || history.length === 0) return console.log('no history found');

      history.sort((a, b) => { return b.date - a.date });
      let formatted = [];
      let min = Number.MAX_SAFE_INTEGER, max = 0, avg = 0, sum = 0;
      history.forEach(h => {
        if (h.ppm) {
          sum += h.ppm;
          min = Math.min(min, h.ppm);
          max = Math.max(max, h.ppm);
        }
        let entry = { date: date.format(new Date(h.date), 'MM/DD hh:mm A') };
        if (!id) entry.peer = peerMap[h.node] || h.node;
        if (h.base) entry.base = h.base;
        if (h.ppm) entry.ppm = h.ppm;
        formatted.push(entry);
      })
      console.log('count:', history.length, 'min:', min, 'max:', max, 'avg:', (sum/history.length).toFixed(1));
      console.table(formatted);
    })
  })

  .command('channel-events', 'Lists channel events')
  .option('--hours [hours]', 'Depth of history in hours')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const hours = options.hours || 24;
      const list = listChannelEvents({hours});
      if (!list || list.length === 0) return console.log('no events found');

      let chanMap = {};
      const chans = listChannelsSync(lndClient);
      chans.forEach(c => {
        chanMap[c.channel_point] = c;
      })
      const peerMap = listPeersMapSync(lndClient);
      let formatted = [];
      let notFound = {};
      list.forEach(event => {
        const key = event.txid + ':' + event.ind;
        const chan = chanMap[key];
        if (!chan) {
          if (!notFound[key]) {
            console.warn('did not find channel for channel point ' + key + '; the channel was likely closed');
            notFound[key] = true;
          }
          return;
        }
        const peer = peerMap[chan.remote_pubkey];
        let item = {};
        item.date = date.format(new Date(event.date), 'MM/DD hh:mm:ss A');
        item.type = event.type;
        item.chan = chan.chan_id;
        item.peer = peer.id;
        item.name = peer.name;
        formatted.push(item);
      })
      
      const inactive = inactiveChannels();
      if (inactive && inactive.length > 0) {
        console.log('\nlist of inactive channels; mins column denotes how long a channel has been inactive in minutes (based on recorded channel events)');
        console.table(inactive);
      }
      let msg = 'list of channel events';
      if (hours) msg += ' over the past ' + hours + ' hours';
      console.log('\n' + msg);
      console.table(formatted);
    })
  })

  .command('channeldb', 'Prints stats about the channel.db')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const {getPath} = require('./api/channeldb');
      const {printCheckSize} = require('./api/channeldb');
      const path = getPath();
      if (path) console.log('channel.db is located at', path);
      printCheckSize();
    })
  })

  .command('send-message', 'Sends a message to a node via keysend')
  .argument('<node>', 'Node pub id')
  .argument('<message>', 'Message to send')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const {sendMessage} = require('./api/send-message');
      sendMessage(args.node, args.message);
    })
  })

  .command('update-channel', 'Updates fees on a channel')
  .help('Requires admin.macaroon in api/config.json')
  .argument('<chan>', 'Channel id')
  .option('--base [base]', 'Base fee in msats')
  .option('--ppm [ppm]', 'Ppm in sats per million')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const matches = resolveChannel(args.chan);
      if (!matches) return console.error('found no matches');
      if (matches.length > 1) {
        console.error('found multiple matches: ' + matches);
        return console.log('narrow your selection')
      }

      const chan = matches[0];
      console.log('updating channel:', chan);
      try {
        updateChannelSync(lndClient, {chan: chan, base: options.base, ppm: options.ppm});
        console.log('updated', chan);
      } catch(err) {
        console.error('error:', err.toString());
      }
    })
  })

  .command('close-channel', 'Closes a channel')
  .argument('<chan>', 'Channel id, node id, (partial or full) node alias')
  .option('--fee [fee]', 'Sat/vbyte closing fee, default 1')
  .option('--force', 'Force close the channel')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      const matches = resolveChannel(args.chan);
      if (!matches) return console.error('found no matches');
      if (matches.length > 1) {
        console.error('found multiple matches: ' + matches);
        return console.log('narrow your selection');
      }

      const chanId = matches[0];
      if (args.chan !== chanId) console.log('idenfied channel id:', chanId);

      const {readInput} = require('./api/utils');
      const fee = options.fee || 1; // defailt of 1 sat/vbyte
      if (!options.force && !options.fee) {
        const accept = readInput('accept default fee of ' + fee + ' sat/vbyte (y/n)?');
        if (accept !== 'y') return console.log('provide fee in --fee argument');
      }

      const resp = closeChannel(lndClient, chanId, fee, options.force);
      if (resp.error) {
        console.error('error closing channel:', resp.error.details);
        if (resp.error.details.indexOf('try force closing it instead') >= 0) {
          console.log('the error indicates that the channel is offline and can not be co-operatively closed');
          const accept = readInput('would you like to force close the channel? (y/n)');
          if (accept === 'y') {
            const ret = closeChannel(lndClient, chanId, undefined, true);
            console.log(ret);
            if (ret.error) return console.error('error force closing the channel:', ret.error.details);
            return console.log('the channel is force closed');
          }
        }
      } else {
        console.log('the channel is closed');
      }
    })
  })

  .command('reconnect', 'Reconnects to disconnected peers')
  .help('Same as BalanceOfSatoshis (bos) reconnect; calls bos api')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      if (!isLndAlive(lndClient)) return reject('lnd is offline');

      reconnect(logger);
    })
  })

cap.parse(process.argv);


function runMonitorStatusLoop() {
  console.clear();
  console.log(date.format(new Date, 'MM/DD hh:mm:ss A'));

  if (!serviceUtils.Rebalancer.isRunning()) {
    return console.log('rebalancer isnt running');
  }

  let arr = rebalanceStatus();
  if (arr.outbound.length === 0)  {
    console.log('no [outbound] peers found');
  } else {
    console.log('rebalance status for [outbound] peers');
    console.table(arr.outbound);
  }
  if (arr.balanced.length === 0)  {
    console.log('no [balanced] peers found');
  } else {
    console.log('\nrebalance status for [balanced] peers');
    console.table(arr.balanced);
  }
}

function runMonitorLoop(inProgress) {
  const hours = 4;

  // load data before clearing screen
  let list = listActiveRebalancesFormattedSync();

  let htlcs, history, closed;
  if (!inProgress) {
    htlcs = pendingHtlcsFormattedSync();
    history = rebalanceHistoryFormattedSync(hours * 60 * 60).filter(r => r.status === 'success');
    closed = listForcedClosingFormattedSync();
  }

  console.clear();

  // active rebalances
  console.log(date.format(new Date, 'MM/DD hh:mm:ss A'));
  if (list) {
    list.forEach(l => l.amount = withCommas(l.amount));
    list.sort(function(a, b) { return a.from.localeCompare(b.from); });
    console.log('rebalances in progress:');
    console.table(list);
  } else {
    console.log('no active rebalances');
  }

  if (inProgress) return; // show only in-progress rebalances

  // rebalance history
  const maxHistoryLines = constants.monitor.rebalanceHistoryLines;
  if (history.length > 0) {
    console.log(`\nsuccessful rebalances over the past ${hours} hour(s) (${maxHistoryLines} max lines):`);
    console.table(history.slice(0, maxHistoryLines));
  }

  // pending htlcs
  if (htlcs && htlcs.length > 0) {
    console.log('\npending htlcs:');
    console.table(htlcs);
  }

  // forced closed
  if (closed && closed.length > 0) {
    console.log('\nforced closing channels:');
    console.table(closed);  
  }

  console.log('\nservices:');
  printStatus();
  // warn about daddy, as it has to be on all the time. telegram needs to be first
  // configured, so add an extra warning in the monitor
  if (!serviceUtils.Launcher.isRunning()) {
    console.error(constants.colorYellow, 'daddy service is not running, this means that other services won\'t be auto-restarted in case of an error. jet start daddy');
  }
  if (!serviceUtils.TelegramBot.isRunning()) {
    console.error(constants.colorYellow, 'telegram bot service is not running, you won\'t get notified about important events.', constants.telegramBotHelpPage);
  }

  // check that the auto rebalancer isnt stuck
  let last = readLastLineSync(serviceUtils.Rebalancer.log);
  if (last && last.toLowerCase().indexOf('error') >= 0) {
    console.error(constants.colorRed, '\ndetected an error in the rebalancer log file:', last);
    console.log('it is possible that the rebalancer is stuck. consider restarting: jet restart rebalancer');

    // notify via telegram
    const {sendTelegramMessageTimed} = require('./api/utils');
    const interval = 5; // minutes
    const msg = 'detected an error in the rebalancer log file. the rebalancer may be stuck. consider restarting: jet restart rebalancer';
    sendTelegramMessageTimed(msg, 'telegramNotifiedRebalancerError', interval * 60);
  }

  // check channel db size
  try {
    const {printCheckSize} = require('./api/channeldb');
    console.log();
    printCheckSize();
  } catch(error) {
    console.error(constants.colorRed, 'error checking channel.db size:', error.toString());
  }
}
